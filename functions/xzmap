#!/usr/bin/env zsh
# -*- mode: sh;sh-indentation: 4;indent-tabs-mode: nil;sh-basic-offset: 4; -*-
#
# Copyright (c) 2023 Sebastian Gniazdowski
#

# Recognize and save info on run as `#!/usr/bin/env zsh` script
[[ $0 != xzmap || -n $ZSH_SCRIPT ]]&&integer bescript=1
0="${${(M)${0::=${(%):-%x}}:#/*}:-$PWD/$0}"

source "$0:h:h/share/preamble.inc.zsh"

: ${XZLOG:=$(mktemp)}

# Input/options
local -A Opts
builtin zparseopts -D -E -A Opts -- || return 1

local f=$1
shift

builtin type xzmsg &>$XZLOG||alias xzmsg=xzmsg
 
[[ -z $f ]]&&{
    xzmsg -h {208}Error:{137} Missing first arg: runnable name/path
    return 1
}

if ! type $f &>$XZLOG; then
    xzmsg -h {208}Error:{137} Couldn\'t find runnable: {33}$f
    return 3
fi

(($# <= 0))&&{
    xzmsg -h {208}Error:{137} Missing arguments: the objects to run ·{33}$f\
        {137}· on
    return 1
}

REPLY= reply=()
local qe ec

for qe; do
    repeat 1 {$f $qe&&{ec+=0;reply+=("$REPLY");}||{ec+=$(($?%10));reply+=("");};}
done
REPLY=$ec

# At least 1 zero code exists?
[[ REPLY != <1-9># ]]&&integer have_output=1

# If run as script, then output via stdout
if ((have_output&&bescript));then
    print -r -- $REPLY
    printf %s\\n "${reply[@]}"
fi
return 1-have_output
